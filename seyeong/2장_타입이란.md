## 2.1 타입이란

### 자료형으로서의 타입

#### 메모리와 타입의 관계

- 컴퓨터의 메모리 공간은 한정적임
- 특정 메모리에 값을 효율적으로 저장하려면 메모리 공간을 차지할 값의 크기를 알아야 함
- 값의 크기를 명시하면 컴퓨터가 값을 참조할 때 한번에 읽을 메모리 크기를 알 수 있어 값을 훼손하지 않고 가져올 수 있음
- 예: 메모리에 숫자 타입 값이 할당되어 있다면 자바스크립트 엔진은 이 값을 숫자로 인식해서 8바이트 단위로 메모리 공간에 저장된 값을 읽어옴

#### 자바스크립트의 7가지 자료형

- undefined
- null
- Boolean
- String
- Symbol
- Numeric (Number와 BigInt)
- Object

#### 데이터 타입의 의미

- 위와 같은 유형을 데이터 타입 또는 자료형이라 함
- 데이터 타입은 데이터 종류를 식별하는 분류체계로 컴파일러에 값의 형태를 알려줌
- 개발자는 타입을 사용해서 값의 종류를 명시할 수 있고 메모리를 더욱 효율적으로 사용할 수 있음

### 집합으로서의 타입

#### 타입과 집합의 관계

- 프로그래밍에서의 타입은 수학의 집합과 유사함
- 타입은 값이 가질 수 있는 유효한 범위의 집합을 의미함

#### 타입 시스템의 역할

- 타입 시스템은 코드에서 사용되는 유효한 값의 범위를 제한함
- 이를 통해 런타임에서 발생할 수 있는 유효하지 않은 값에 대한 에러를 방지해줌
- 코드의 안정성과 예측 가능성을 높여줌

### 정적 타입과 동적 타입

<u>타입을 결정하는 시점</u>에 따라 프로그래밍 언어는 정적 타입과 동적 타입으로 분류

| 구분               | 정적 타입 시스템                                                                           | 동적 타입 시스템                                                                                              |
| ------------------ | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| **타입 결정 시점** | 컴파일 타임                                                                                | 런타임                                                                                                        |
| **타입 명시**      | 개발자가 코드 수준에서 명시                                                                | 개발자가 직접 타입 정의하지 않음                                                                              |
| **예시 언어**      | Java, C++, TypeScript, Rust                                                                | JavaScript, Python, Ruby                                                                                      |
| **장점**           | 타입 관련 오류를 컴파일 시점에 발견<br>코드 자동완성 및 intellisense 지원<br>리팩토링 용이 | 빠른 개발 속도<br>타입 선언 불필요<br>유연한 프로그래밍                                                       |
| **단점**           | 개발 초기 단계에서 더 많은 코드 작성 필요<br>타입 선언으로 인한 코드량 증가                | 런타임에서 타입 예측이 어려움<br>타입 관련 오류가 실행 중에 발견됨<br>대규모 애플리케이션에서 유지보수 어려움 |

### 강타입과 약타입

암묵적 타입 변환 여부에 따라 타입 시스템은 강타입과 약타입으로 분류

| 구분          | 강타입 (Strong Type)                                                      | 약타입 (Weak Type)                                                                                                        |
| ------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |
| **특징**      | 서로 다른 타입끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러 발생 | 서로 다른 타입을 갖는 값끼리 연산할 때 컴파일러 또는 인터프리터가 내부적으로 판단해서 특정 값의 타입을 변환하여 연산 수행 |
| **예시 언어** | Python, Ruby, **TypeScript**                                              | JavaScript, PHP, C                                                                                                        |
| **장점**      | 타입 안정성 증가<br>의도하지 않은 동작 방지<br>명확한 타입 경계           | 개발 편의성 증가<br>타입 변환 작업 감소<br>빠른 개발 가능                                                                 |
| **단점**      | 명시적 타입 변환 코드 필요<br>약간의 추가 작업 필요                       | 예기치 못한 오류 발생 가능성 높음<br>개발자의 의도와 다르게 동작할 수 있음<br>디버깅 어려움                               |

#### 언어 분류에 대한 참고 사항

- TypeScript는 강타입의 특성을 갖추고 있지만, JavaScript 호환성을 위해 일부 약타입 특성도 가지고 있음

#### 타입스크립트의 타입 시스템 접근 방식

타입스크립트는 두 가지 타입 시스템 접근 방식의 영향을 받음

1. **명시적 타입 선언**: 개발자가 직접 타입을 명시

   ```typescript
   const name: string = "John";
   const age: number = 30;
   ```

2. **타입 추론**: 타입스크립트가 자동으로 타입을 추론
   ```typescript
   const name = "John"; // string으로 추론됨
   const age = 30; // number로 추론됨
   ```

### 컴파일 방식

#### 일반적인 컴파일

- 보통 컴파일은 사람이 이해할 수 있는 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정
- Java, C# 등의 언어에서 컴파일러는 해당 코드들을 바이너리 코드로 변환
- 일반적으로 컴파일은 고수준 언어에서 저수준 언어로의 코드 변환을 의미

#### 타입스크립트의 컴파일

- **타입스크립트는 컴파일하면 자바스크립트가 됨**
- 이는 일반적인 컴파일 과정과는 다른 특징
- 타입스크립트의 컴파일 과정은 엄밀히 말하면 '트랜스파일'에 가까움
  - 트랜스파일: 비슷한 수준의 언어 간 변환 과정 (고수준 → 고수준)
  - 타입스크립트 → 자바스크립트 변환은 저수준 언어로의 변환이 아닌, 다른 고수준 언어로의 변환

## 2.2 타입스크립트의 타입 시스템

### 타입 애너테이션

### 덕 타이핑, 구조적 타이핑, 명목적 타이핑

- 명목적 타이핑:
  - 이름으로 타입을 구분
  - 타입의 동일성을 확인하는 과정에서 구조적 타이핑보다 좀 더 안전
- 구조적 타이핑:

  ```typescript
  interface Pet {
    name: string;
  }

  interface Cat {
    name: string;
    age: number;
  }

  let pet: Pet;
  let cat: Cat = { name: "a", age: 2 };

  pet = cat;
  console.log(pet);
  ```

- 구조적 서브타이핑:
- 서브타입과 상위타입의 관계
- 덕 타이핑:

  - 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는 것으로 간주하는 방식
  - 어떤 함수의 매개변수값이 올바르게 주어진다면 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용

- 명목적 타이핑 vs 구조적 타이핑, 덕 타이핑
- 구조적 타이핑 vs 덕 타이핑
  - 두개 다 모두 객체가 가진 속성을 기반으로 타입을 검사!
    - 객체 변수, 메서드 같은 필드를 기반으로 타입 검사
  - 차이는 그냥 타입 검사 시점임
    - 덕타이핑: 런타임에서 타입 검사, 동적 타이핑 / 구조적 타이핑: 컴파일타임에 타입체커가 타입 검사, 정적 타이핑

### 타입스크립트가 구조적 타이핑을 채택한 이유

명목적 타이핑이 좀 더 안전한데 왜 구조적 타이핑을 채택햇을가?

- 타입스크립트가 자바스크립트를 모델링한 언어이기 때문
- 자바스크립트는 본질적으로 덕 타이핑을 기반으로 함
- 구조적 타이핑 덕분에 ts는 더욱 유연한 타이핑이 가능

### 구조적 타이핑의 결과

```typescript
interface Cube {
  width: number;
  height: number;
}
function addLines(c: Cube) {
  let total = 0;
  for (const axis of Object.keys(c)) {
    const length = c[axis];
    total += length;
  }
}
```

- 문제1)
- 문제2) c에 들어올 객체는 Cube의 속성 이외에도 어떤 속성이든 가질 수 있기 때문에 문제 -> `c[axis]` 의 타입이 number라고 확정할 수 없음

### 타입스크립트의 점진적 타입 확인

- 타입스크립트는 점진적으로 타입을 확인하는 언어
- 점진적 타입 검사: 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식
- 타입 선언이 생략되면 동적으로 검사를 수행한다
- 자바스크립트에서 마이그레이션할 때 유용함
- 그러나 이런 특성 때문에 타입 시스템은 정적 타입의 정확성을 100% 보장해주진 않음
  ```typescript
  const names = ["1", "2"];
  console.log(names[2].toUpperCase()); // 런타임 에러 발생
  ```

## 2.3 원시 타입

### 자바스크립트와 타입스크립트에서의 원시값과 원시 래퍼 객체

#### 자바스크립트

- 원시값

  - 불변하는 기본 데이터 값: string, number, boolean, null, undefined, symbol, bigint
  - typeof로 확인 시 원시 타입명 반환 ("string", "number" 등)
  - 메서드가 없음 (메서드 호출 시 임시 래퍼 객체 생성)

- 원시 래퍼 객체
  - 생성자로 만들어짐: new String("hello"), new Number(42) 등
  - typeof로 확인 시 "object" 반환
  - 객체이므로 항상 truthy로 평가됨 (new Boolean(false)도 truthy)
  - valueOf()로 원시값 추출 가능

#### 타입스크립트

- 타입 시스템
  - 원시 타입: string, number, boolean 등 (소문자)
  - 래퍼 객체 타입: String, Number, Boolean 등 (대문자)
- 할당 관계
  - 원시 타입은 래퍼 객체 타입에 할당 가능
    ```typescript
    let s = (String = "hello"); // 가능
    ```
  - 래퍼 객체는 원시 타입에 할당 불가능
    ```typescript
    let s = (string = new String("hello")); // 오류
    ```
- 서브타입 관계
  - 원시 타입은 해당 래퍼 객체 타입의 서브타입으로 취급됨
  - 이는 일반적인 객체지향 상속 관계가 아닌 타입스크립트의 특별한 할당 규칙
- 실무 권장사항
  - 타입스크립트에서 타입 선언 시 원시 타입 사용 권장

### boolean - 오직 `true`와 `false` 값만 할당 가능

- boolean 원시 값은 아니지만 형 변환을 통해 true/false로 취급되는 `Truthy / Falsy` 값들은 타입스크립트에서도 boolean 타입에 속하지 않는다

<details>
<summary>`Truthy / Falsy` 공식문서를 보고 넘어가요</summary>

- [Falsy 값](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)
- [Truthy 값](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)

</details>

### undefined - 오직 `undefined` 값만 할당 가능

- 정의되지 않았다는 의미의 타입
- 초기화되어 있지 않거나 존재하지 않음(ex: 타입의 옵셔널 속성)을 의미

### null - 오직 `null`만 할당 가능

- "빈 값"을 할당해야할 때 사용
- 명시적 + 의도적으로 값이 비어있음을 보여준다.
- undefined과 null은 동등 연산자(==)로 비교 시, true가 나오지만 엄연히 다른 원시 값이기에 서로의 타입에 할당 불가

### null과 undefined

- 타입스크립트의 모든 타입은 기본적으로 null이나 undefined를 포함함
- tsconfig의 strictNullChecks 옵션 활성화 시
  - 사용자가 명시적으로 해당 타입에 null이나 undefined를 포함해야 사용 가능
  - 그렇지 않으면 null과 undefined가 될 수 있는 경우에 타입스크립트 에러 발생
- 처리 방법
  1. 타입 가드를 사용하여 null과 undefined를 걸러내는 방법
  2. [Non-null 단언 연산자(!)를 사용하여 타입 단언](https://inpa.tistory.com/entry/TS-%F0%9F%93%98-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%8A%90%EB%82%8C%ED%91%9C-Non-null-%EB%8B%A8%EC%96%B8-%EC%97%B0%EC%82%B0%EC%9E%90)

### number - 숫자에 해당하는 모든 원시 값 할당 가능

- byte, short, int, long, double, float과 같은 다양한 숫자 타입을 가지는 자바 같은 언어와는 달리, 자바스크립트의 숫자는 정수와 부동소수점수를 구분하지 않기 때문에 모두 number 타입에 할당
- NaN, Infinity도 number 타입
  - 둘 다 원시 값이다
    ```typescript
    // 아래 코드는 타입 오류 발생 안함
    let a: number = NaN;
    let b: number = Infinity;
    ```

### [bigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) - Number.MAX_SAFE_INTEGER(2<sup>53</sup>-1) 보다 큰 값 할당

```typescript
const bigNumber1: bigint = BigInt(999999999999);
const bigNumber2: bigint = 999999999999n;
```

- ES2020부터 도입된 데이터 타입, 타입스크립트 3.2버전부터 사용 가능
  - 기존에는 Number.MAX_SAFE_INTEGER(2<sup>53</sup>-1)를 넘어가는 값을 처리할 수 없었는데, bigInt를 사용하면 이보다 더 큰 숫자 처리 가능
  - bigInt에 대한 설명은 https://ko.javascript.info/bigint 참고
- number와는 엄연히 서로 다른 타입

### string - 문자열 할당

- 공백도 string 타입

### symbol

```typescript
const MOVIE_TITLE = Symbol("title");
const MUSIC_TITLE = Symbol("title");
console.log(MOVIE_TITLE === MUSIC_TITLE); // 동일한 "title" 문자열을 가지고 만들었지만 결과는 false

let SYMBOL: unique symbol = Symbol(); // 타입 에러 발생: A variable whose type is a 'unique symbol' type must be 'const'
```

- ES2015부터 도입된 데이터 타입
- Symbol()함수를 사용하면 어떤 값과도 중복되지 않는 유일한 값 생성 가능
- 타입스크립트에는 두 가지 Symbol 타입이 존재
  - `symbol` 타입: 일반적인 Symbol 인스턴스의 타입
  - `unique symbol` 타입: const 선언에서만 사용할 수 있는 Symbol의 하위 타입

## 2.4 객체 타입

### object

### {}

### array

### type과 interface 키워드

### function
